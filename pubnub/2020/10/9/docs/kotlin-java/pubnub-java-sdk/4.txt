import com.google.gson.JsonObject

import com.pubnub.api.PNConfiguration
import com.pubnub.api.PubNub
import com.pubnub.api.callbacks.SubscribeCallback
import com.pubnub.api.enums.PNStatusCategory
import com.pubnub.api.models.consumer.PNStatus
import com.pubnub.api.models.consumer.pubsub.PNMessageResult
import com.pubnub.api.models.consumer.pubsub.PNPresenceEventResult

fun main() {
    val config = PNConfiguration()
    config.subscribeKey = "mySubKey"
    config.publishKey = "myPubKey"
    config.uuid = "myUniqueUuid"

    val pubnub = PubNub(config)

    val myChannel = "awesomeChannel"
    val myMessage = JsonObject().apply {
        addProperty("msg", "hello")
    }

    println("Message to send $myMessage")

    pubnub.addListener(object : SubscribeCallback() {

        override fun status(pubnub: PubNub, status: PNStatus) {
            when (status.category) {
                PNStatusCategory.PNConnectedCategory -> {
                    // Connect event. You can do stuff like publish, and know you'll get it.
                    // Or just use the connected event to confirm you are subscribed for
                    // UI / internal notifications, etc
                }
                PNStatusCategory.PNReconnectedCategory -> {
                    // Happens as part of our regular operation.
                    // This event happens when radio / connectivity is lost, then regained.
                }
                PNStatusCategory.PNUnexpectedDisconnectCategory -> {
                    // This event happens when radio / connectivity is lost
                }
            }
        }

        override fun message(pubnub: PubNub, pnMessageResult: PNMessageResult) {
            if (pnMessageResult.channel == myChannel) {
                println("Received message ${pnMessageResult.message.asJsonObject}")
            }
        }

        override fun presence(pubnub: PubNub, pnPresenceEventResult: PNPresenceEventResult) {
            // handle presence
        }
    })

    pubnub.subscribe().apply {
        channels = listOf(myChannel)
    }.execute()

    pubnub.publish().apply {
        channel = myChannel
        message = myMessage
    }.async { result, status ->
        println(status)
        if (!status.error) {
            println("Message sent, timetoken: ${result!!.timetoken}")
        } else {
            println("Error while publishing")
            status.exception?.printStackTrace()
        }
    }
}