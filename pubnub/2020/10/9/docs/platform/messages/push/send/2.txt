var pubnub: PubNub!func application(_ application: UIApplication, didFinishLaunchingWithOptionslaunchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {/*STEP 1: Ask user for permission to receive push; register with APNs if allowed*/let center = UNUserNotificationCenter.current()center.getNotificationSettings { (settings) in  switch settings.authorizationStatus {    case .notDetermined:      center.requestAuthorization(options: [.alert, .sound, .badge],      completionHandler: { (granted, error) in        // You might want to remove this        /// or handle errors differently in production        assert(error == nil)        if granted {          UIApplication.shared.registerForRemoteNotifications()        }      })    case .authorized, .provisional:      UIApplication.shared.registerForRemoteNotifications()    case .denied:      print("We can't use notifications because the user has denied permissions")    @unknown default:      print("Unknown status")  }}return true}func application(_ application: UIApplication,  didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {/*STEP 2: Receive device push token from APNs*/print("Received device push token from APNs: \(deviceToken)")/*STEP 3: Is the new device token different than the old device token*/let defaults = UserDefaults.standardlet oldDeviceToken = defaults.data(forKey: "DeviceToken")// if token is different from previous token,// then store locally and associate for push on channels with new tokenif (oldDeviceToken != deviceToken) {defaults.set(deviceToken, forKey: "DeviceToken")defaults.synchronize()if (oldDeviceToken != nil) {  pubnub.removeAllPushChannelRegistrations(for: oldDeviceToken!) { result in    switch result {      case let .success(response):        print("Successful Push Deletion Response: \(response)")      case let .failure(error):        print("Failed Push Deletion Response: \(error.localizedDescription)")    }  }}/*STEP 4: associate push notifications with channels for PubNub*/pubnub.modifyAPNSDevicesOnChannels(    byRemoving: [],    thenAdding: ["chats.room1", "chats.room2", "alerts.system"],    device: deviceToken,    on: "com.example.chat",    environment: .production) { result in    switch result {        case let .success(response):          print("Successful Push Modification Response: \(response)")        case let .failure(error):          print("Failed Push List Response: \(error.localizedDescription)")    }}}}func application(_ application: UIApplication,   didFailToRegisterForRemoteNotificationsWithError error: Error) {   // The token isn't currently available   print("Remote notification support is unavailable due to error:\(error)")}func application(   _ application: UIApplication,   didReceiveRemoteNotification userInfo: [AnyHashable: Any],   fetchCompletionHandler completionHandler:   @escaping (UIBackgroundFetchResult) -> Void) {/*STEP 5: provide a means to receive push notifications*/guard let aps = userInfo["aps"] as? [String: AnyObject] else {    completionHandler(.failed)    return}// you might just do nothing if you do not want to display anything// there techniques for displaying silent push Notifications// but leaving that to Apple docs for those details}show all 112 lineshide 97 linesCopy